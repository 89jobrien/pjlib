#!/usr/bin/env -S uv run --script
# pyright: reportArgumentType=false
# /// script
# requires-python = ">=3.12"
# dependencies = []
# ///

"""
Generate markdown summary of what was accomplished in the session when stopping.

This hook creates a summary of the session's activities.
Runs on Stop event.
"""

import json
import os
import sys
from datetime import datetime
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent.parent))
from hook_logging import hook_invocation


def default_stats() -> tuple[dict[str, int], list[str]]:
    return (
        {
            "files_written": 0,
            "files_edited": 0,
            "commands_run": 0,
            "searches": 0,
            "reads": 0,
        },
        [],
    )


def get_summary_dir() -> Path:
    """Get the directory for session summaries."""
    summary_dir = Path.home() / "logs" / "claude-code" / "session-summaries"
    summary_dir.mkdir(parents=True, exist_ok=True)
    return summary_dir


def analyze_transcript(transcript_path: str) -> tuple[dict[str, int], list[str]]:
    """Analyze transcript to extract key information."""
    path = Path(transcript_path)
    if not path.exists():
        return default_stats()

    try:
        content = path.read_text()
    except (OSError, UnicodeDecodeError):
        return default_stats()

    # Extract file paths mentioned
    import re

    file_paths: list[str] = re.findall(r'"file_path":\s*"([^"]+)"', content)
    files_touched: list[str] = sorted(set(file_paths))[:20]  # Limit to 20

    # Count different activities
    stats, _ = default_stats()
    stats["files_written"] = content.count('"tool_name": "Write"')
    stats["files_edited"] = content.count('"tool_name": "Edit"') + content.count(
        '"tool_name": "MultiEdit"'
    )
    stats["commands_run"] = content.count('"tool_name": "Bash"')
    stats["searches"] = content.count('"tool_name": "Grep"') + content.count(
        '"tool_name": "Glob"'
    )
    stats["reads"] = content.count('"tool_name": "Read"')

    return stats, files_touched


def generate_summary(stats: dict[str, int], files_touched: list[str], cwd: str) -> str:
    """Generate markdown summary."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    summary = f"""# Session Summary

**Date:** {timestamp}
**Working Directory:** {cwd}

## Activity Overview

| Metric | Count |
|--------|-------|
| Files Written | {stats.get("files_written", 0)} |
| Files Edited | {stats.get("files_edited", 0)} |
| Commands Run | {stats.get("commands_run", 0)} |
| Searches | {stats.get("searches", 0)} |
| Files Read | {stats.get("reads", 0)} |

## Files Touched

"""

    if files_touched:
        for f in files_touched:
            summary += f"- `{f}`\n"
    else:
        summary += "_No files tracked_\n"

    summary += """
## Notes

_Add your own notes about this session here_

---
*Generated by session_summary hook*
"""

    return summary


def main() -> None:
    with hook_invocation("session_summary") as inv:
        try:
            payload = json.load(sys.stdin)
        except json.JSONDecodeError:
            sys.exit(0)

        inv.set_payload(payload)

        if payload.get("stop_hook_active"):
            sys.exit(0)

        transcript_path = payload.get("transcript_path", "")
        cwd = payload.get("cwd", ".")

        # Analyze the session
        stats, files_touched = (
            analyze_transcript(transcript_path) if transcript_path else default_stats()
        )

        # Skip if minimal activity
        total_activity = (
            int(stats.get("files_written", 0))
            + int(stats.get("files_edited", 0))
            + int(stats.get("commands_run", 0))
        )

        if total_activity < 3:
            # Not enough activity to warrant a summary
            sys.exit(0)

        # Generate summary
        summary = generate_summary(stats, files_touched, cwd)

        # Save summary
        summary_dir = get_summary_dir()
        session_id = os.environ.get("CLAUDE_SESSION_ID", str(os.getpid()))
        date_str = datetime.now().strftime("%Y%m%d_%H%M%S")

        summary_path = summary_dir / f"summary_{date_str}_{session_id}.md"

        try:
            summary_path.write_text(summary)
            print(
                f"[Success] Session summary saved to {summary_path.name}",
                file=sys.stderr,
            )
        except OSError as e:
            print(f"[Warning] Failed to save summary: {e}", file=sys.stderr)

        sys.exit(0)


if __name__ == "__main__":
    main()
